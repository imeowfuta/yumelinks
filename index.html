<!doctype html><html lang="en"
style='
--startx: 3;
--starty: 2;
--cols: 16;
--rows: 16;
--backgroundscrollspeedx: 0.5;
--backgroundscrollspeedy: 0.1;
--backgroundsize: 30%;
--links: "0,0 6,2 https://en.wikipedia.org/wiki/Torrent_duck \n10,6 https://archive.org/search?query=Killing+Hope";
--levelstate: 3,0 1,0 2,0 2,0 1,0 1,0 1,0 1,0 2,0 2,0 2,0 2,0 2,0 2,0 2,0 2,0 1,0 1,0 2,0 0,0 0,0 0,0 0,0 0,0 0,0 2,0 2,0 2,0 2,0 2,0 2,0 2,0 1,0 0,0 2,0 0,0 0,0 1,0 3,0 1,0 0,0 0,0 2,0 2,0 0,0 2,0 2,0 2,0 0,0 4,0 2,0 4,0 4,0 1,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 2,0 2,0 0,0 4,0 2,0 .,. .,. 4,0 1,0 0,0 0,0 0,0 0,0 0,0 1,0 1,0 2,0 2,0 0,0 4,0 2,0 .,. 4,0 0,0 0,0 0,0 1,0 0,0 0,0 0,0 0,0 1,0 2,0 2,0 0,0 0,0 2,0 4,0 0,0 0,0 0,0 0,0 4,0 1,0 3,0 1,0 1,0 2,0 2,0 2,0 1,0 0,0 0,0 0,0 0,0 0,0 4,0 4,0 4,0 1,0 1,0 1,0 1,0 2,0 2,0 2,0 4,0 1,0 0,0 1,0 0,0 4,0 .,. .,. .,. 4,0 1,0 0,0 2,0 2,0 2,0 2,0 .,. 4,0 2,0 4,0 4,0 .,. .,. .,. .,. 4,0 1,0 1,0 2,0 2,0 2,0 2,0 .,. .,. 2,0 .,. .,. .,. .,. .,. .,. .,. 4,0 1,0 2,0 2,0 1,0 0,0 .,. .,. 2,0 .,. .,. .,. .,. .,. .,. .,. 4,0 1,0 2,0 1,0 1,0 1,0 .,. .,. 2,0 .,. .,. .,. .,. .,. .,. .,. 4,0 .,. 2,0 1,0 4,0 4,0 .,. .,. 2,0 .,. .,. .,. .,. .,. .,. .,. 4,0 .,. 2,0 4,0 .,. .,. .,. .,. 2,0 .,. .,. .,. .,. .,. .,. .,. .,. .,. 2,0 .,. .,. .,. .,. .,. 2,0 .,. .,. .,. .,. .,. .,. .,. .,. .,. 2,0 .,. .,. .,.;
--walls: 2,0 3,0 4,0;
--tilesetsprite: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEABAMAAACuXLVVAAAAD1BMVEUAAACZmZlmZplmZmYzZpko+ityAAAAAXRSTlMAQObYZgAAAQ9JREFUeNrt1MGRwjAQRFFSaA8JuFECg0hgxeQf0xa2Wba4Iy7/HXzw6ZeqpZPe+KCHRTp9mjapJ1fZbmPxInlSQCgVqa6QquxWw1q8ao0pAamU1CO7Mm23Klt99WJPCMjQJiJSSrtq2Fasi7Wsnw+IV8DbCK8XTRvhi92qypbieslvBNQ+Q+nc+883Ah5aDalX9SkBud/DQ/NOuvd+mxDQQ1JsH0VKNZ4Bt6r7hIAI7TKkrm67arR5J6Cn/STS+wotnavmjDD0J0I+aBM55yn+pw17uNX+N75yDcutSocTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAh/0C3aM3uPegxg0AAAAASUVORK5CYII="); 
--playersprite: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACAAgAAAACs5Sa2AAAAAnRSTlMAAQGU/a4AAAK7SURBVHja7ZfBattAFEXfoMxOwdlo1/6DismuoRNM6CaQCY7QxuBf6KJLQ39thNEuELrwf6iE7FpU9N4LlxlbGIEhEJLN1Z1ziJ2Rxnmm6sgPnUTwFr1Ch5BTBLRDeCip4Ou5AO0QlkSWQRCgHYKXBWQqOCIDgJ4IyJML6WujYx+ICgB07CRRBcBZjf4GzSIRFDjD6VwkDCBjcO3MNWcQEULIBGjakMXCIlCrwA/5nViM7uZOAP0esiZqI2GtQo18iYQV0eVwuVagHcKGFwD2hB+8Dyxe6UadH9zJn0SfseWR4AsFkjYVjLP8sBrXDumNG7kXyGnCYOA9oB45vG8lLO2RD5BHtVeHP0BwD/Ye+5AcHO4Tjt6U0503I0LeCkAmwnwnoOfkDgHAZz1ECAAPs07FWAD41lcqJoICP/sngnYICtxFwakdglfg+CahQ/gk4MwZTu0Q3ELAjaYTEcK9gmpBHNohVLekAjIWNrqQkb7bkAglAwjUcUIgBY50rYwEAC/BPRKsU8C3AB2n27UiWA7ukZA7i8cdHUL0f0L6yF/B69ynHN6P+eGE88O8NADoEJ7mBmDoX2Nh2fctg2cRtUOo+34HgI6d3G4LAHTsZN/zgt9uLSf3+BPmFXC6uy4WfND54e7P65gwMj90Y/ND9hzPD0+hifch63YMZkHmh1nYmx9eFAzi0HfT5oc1LwBsDkwg55gfeJ64fIP5QQCRiO98fvDvYX5YlCPCUkCaEOpHWah7Tu0QAPpgIUIAmPGhlQ4BoOr/QoTAQBZ+dVbFSBiADg5nRsVIGIDVmySCdggrXXDmgtNHAgMjQnPPeduYRGhu5Lrh4A4BAPmFA0Km742Crl2lYxJB4MwTISe9NipQJAxAi4UYCcbLdS1AO4Sl0YfUi6AdgjdlgccdHQLh+I99AanwEtynHN7/JGfMtvZgnCUAAAAASUVORK5CYII=");
--worldbackgroundsprite: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAMAAAD04JH5AAADAFBMVEUAAAAAADMAAGYAAJkAAMwAAP8AMwAAMzMAM2YAM5kAM8wAM/8AZgAAZjMAZmYAZpkAZswAZv8AmQAAmTMAmWYAmZkAmcwAmf8AzAAAzDMAzGYAzJkAzMwAzP8A/wAA/zMA/2YA/5kA/8wA//8zAAAzADMzAGYzAJkzAMwzAP8zMwAzMzMzM2YzM5kzM8wzM/8zZgAzZjMzZmYzZpkzZswzZv8zmQAzmTMzmWYzmZkzmcwzmf8zzAAzzDMzzGYzzJkzzMwzzP8z/wAz/zMz/2Yz/5kz/8wz//9mAABmADNmAGZmAJlmAMxmAP9mMwBmMzNmM2ZmM5lmM8xmM/9mZgBmZjNmZmZmZplmZsxmZv9mmQBmmTNmmWZmmZlmmcxmmf9mzABmzDNmzGZmzJlmzMxmzP9m/wBm/zNm/2Zm/5lm/8xm//+ZAACZADOZAGaZAJmZAMyZAP+ZMwCZMzOZM2aZM5mZM8yZM/+ZZgCZZjOZZmaZZpmZZsyZZv+ZmQCZmTOZmWaZmZmZmcyZmf+ZzACZzDOZzGaZzJmZzMyZzP+Z/wCZ/zOZ/2aZ/5mZ/8yZ///MAADMADPMAGbMAJnMAMzMAP/MMwDMMzPMM2bMM5nMM8zMM//MZgDMZjPMZmbMZpnMZszMZv/MmQDMmTPMmWbMmZnMmczMmf/MzADMzDPMzGbMzJnMzMzMzP/M/wDM/zPM/2bM/5nM/8zM////AAD/ADP/AGb/AJn/AMz/AP//MwD/MzP/M2b/M5n/M8z/M///ZgD/ZjP/Zmb/Zpn/Zsz/Zv//mQD/mTP/mWb/mZn/mcz/mf//zAD/zDP/zGb/zJn/zMz/zP///wD//zP//2b//5n//8z///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlenwdAAABAHRSTlP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG8mZagAAAAlwSFlzAAAOwwAADsMBx2+oZAAAD3JJREFUeJyNW02aJakKlYluRCdSk/c2Uj3p/W+l5QCKhhGZUV9l3oxrCCI/ByRSSonHlZJ+SPtFzJ3224xh5Lco+SdmSj9d8vB5T+ZvuL3mknsyWx2/Fnnyb4xjmrfHk227dyNtS9052P7oTDZDd0ZLGhKQmzTHjG8qU8eNJjP0cbdxPme7MfEUcUqTb4JUm1LD9NRlWU0GdbndVABM2R/2D+NWK5VS/Vp+uu3x5IrG2nKLowb5Yp+7cFSV2iC0Zhm7AWZlWCs8BPax/Bt5ljWZdMfMIvKxm7YuLrqg0jCvCgUj9AnCpMoy9R834LZ6va/TyLdDBGOxuYq0RTOLUBortqFQ0pqEL2ioMMuud7I59UMFOZ0scvigWk9tv4stbVhvs0mMW/lmaAJDrFyLMPYl/nSxvsgFi7V3kUCWVZLdGzf2JcGI2mPqIbCx/e1zC/jcobVSWDD0sMMdCAHiktpQ7L+7cyGe2++mQuC+vG3wJPb+9bAgdygwMTUtcDUMa3+u0jI8tUx8Yqye353Qg3yUB/cmVgYxjL2sPqI8vRbsnow+qRZiWzDDK/XP5csP1Z4i04gmkfj5cncpNJ8TdyiDx6d/hNu/rzQI6vXBjznxYV6pTRcn/j65utH6D75I5hR3WPHo2IH+rgKd+/PmZTSJE7AV5pom0xfJgjy4K2KHJU3XdNKW/+YrA+3THDzGBXfj4eFq2s2Hwj+UKtZy27AZ4q+3nzfZyQf2LxfJNgU4oKpa5jbFSflK7hGNmae+bzMcUnUKYpx4yHap1HK6JlzNPPa5kOBqlajOt7bxLaL608M39KIfBSjk9hpjOCCcJ30fowL4w8sA3qlj9L7iZtDpVEJYUXoawI7tbIdmcP2JPjbMgs70CLndtKVljqMWzeABmacIfrP8jf/gvKORfenQ9nxKycmn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");
--walksound: url("data:audio/mpeg;base64,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");
'>

<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width,initial-scale=1" /></head>

<body>

  <!-- --- HTML --- -->
<p class="instructions" id="instructions">move: arrows/WASD, <br> interact: z/space</p>
<div class="world" id="world" aria-label="yumelinks game world" tabindex="0">
    <canvas class="levelcanvas" id="levelcanvas" aria-hidden="true" role="presentation" tabindex="-1"></canvas>
    <div class="grid" id="grid" aria-hidden="true" role="presentation" tabindex="-1"></div>
    <div class="player" id="player" aria-hidden="true" role="presentation" tabindex="-1"></div>
</div>

<style> /* --- STYLE --- */
  *,*::before,*::after { top: 0; left: 0; margin: 0; padding: 0; border: 0; outline: 0; box-shadow: none; text-decoration: none; -webkit-appearance: none; appearance: none; box-sizing: border-box; image-rendering: crisp-edges; image-rendering: pixelated;}
  body {
    overflow: hidden; height: 100vh; width: 100vw; overscroll-behavior: none;display:flex; align-items:center; justify-content:center; 
    background:#000000;

  /* BLOBED IMAGES */
    --blob_tilesetsprite: null;
    --blob_worldbackgroundsprite: null;
    --blob_playersprite: null;
  /* BLOBED SOUNDS */
    --blob_walksound: null;
  /* PLAYER ANIMATION */
    --visx: 2; --visy: 2;
    --playerspriteframex: 0%; --playerspriteframey: 0%;
  /* CELL SIZE IS DEPENDANT ON PAGE SIZE */
    --cell-size: min(calc(100vw / var(--cols, 16)), calc(100vh / var(--rows, 16)));
  }

  .instructions {
    text-align: right;
    position: absolute;
    bottom: 1rem;  right: 1rem; left: auto; top: auto;
    color: #ffffffcc;
    font-size: 1rem;
    z-index: 10;
    user-select: none;
  }
  .world {
    position: relative;
    display: inline-block;
    width: min(100vw, 100vh);
    height: min(100vw, 100vh);
    overflow: hidden;
    touch-action: none;
    background-image: var(--blob_worldbackgroundsprite);
    background-size: var(--backgroundsize), auto;
    width: calc(var(--cols) * var(--cell-size));  height: calc(var(--rows) * var(--cell-size));
  }
  .levelcanvas {
    position: absolute;
    top: 0;  left: 0;
    width: 100%;  height: 100%;
    image-rendering: crisp-edges;
    image-rendering: pixelated;
    pointer-events: none
  }
  .grid {
    position: absolute;
    top: 0;  left: 0;
    display: grid;
    gap: 0;
    grid-template-columns: repeat(var(--cols), var(--cell-size));  grid-template-rows: repeat(var(--rows), var(--cell-size));
    pointer-events: none
  }
  .cell {
    background: transparent;
    width: 100%;  height: 100%;
    pointer-events: auto
  }
  .player {
    position: absolute;
    top: calc((var(--visy) - 1) * var(--cell-size));
    left: calc((var(--visx) - 0.5) * var(--cell-size));
    background-image: var(--blob_playersprite);
    background-size: calc(100% * 4) calc(100% * 4);
    background-position: var(--playerspriteframex) var(--playerspriteframey);
    width: calc(var(--cell-size)*2);  height: calc(var(--cell-size)*2);
    pointer-events: none
  }
</style>


<script>// --- JAVASCRIPT --- //
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v)); //why isn't this in JS yet?

  const rootStyle = getComputedStyle(document.documentElement);

  function getval(val) { // gets values from saved <html> CSS --variables
    return rootStyle.getPropertyValue( '--' + val);
  }

  let x = parseFloat(getval('startx')) || 2; // sets player to start pos
  let y = parseFloat(getval('starty')) || 2; 

  const params = new URLSearchParams(window.location.search); // override start pos with URL parameter
  const nx = parseInt(params.get('x'), 10);
  if (!Number.isNaN(nx)) x = clamp(nx, 0, parseInt(getval('cols')) - 1);
  const ny = parseInt(params.get('y'), 10);
  if (!Number.isNaN(ny)) y = clamp(ny, 0, parseInt(getval('rows')) - 1);

  const world = document.getElementById('world'); // gets the main <html> elements
  const levelCanvas = document.getElementById('levelcanvas');
  const player = document.getElementById('player');

  let moving = false; //is player in moving animation
  let facing = 2; // 0=up,1=right,2=down,3=left
  let visx = x; //visual used for animations and timing
  let visy = y;
  let tilefacingx = 0; // coord player is facing for tile interactions
  let tilefacingy = 0;
  let bgPosX = 0; // background position for parallax
  let bgPosY = 0;

  document.body.style.setProperty('--visx', visx); // sets runtime css properties in the body style
  document.body.style.setProperty('--visy', visy);
  document.body.style.setProperty('--playerspriteframex', '0%');
  document.body.style.setProperty('--playerspriteframey', '0%');

// BLOB PROCCESSING FUNCTIONS

  const _prevBlobUrls = {}; // cache list for css blob: URL so we can revoke old ones when updated

  function _stripUrlWrapper(cssVal) {
    const mm = String(cssVal).trim().match(/url\((['"]?)(.*?)\1\)/);
    return mm ? mm[2] : cssVal.trim();
  }

  function convertCssDataUrlVarToBlob(baseVar) { // converts the css variable that contains a data into a blob: URL stored in a separate CSS var
    const blobVar = baseVar.replace(/^--/, '--blob_');
    const raw = getComputedStyle(document.documentElement).getPropertyValue(baseVar) || '';
    const val = _stripUrlWrapper(raw);

    if (val.startsWith('data:')) { // if it's a data: URL convert to Blob and create blob: URL
      const [, mime = 'application/octet-stream', base64Flag, payload] =
        String(val).match(/^data:([^;,]+)?(;base64)?,(.*)$/);
      const str = base64Flag ? atob(payload) : decodeURIComponent(payload);
      const blob = new Blob([Uint8Array.from(str, c => c.charCodeAt(0))], { type: mime });

      const url = URL.createObjectURL(blob);
      // revoke previous blob URL if exists and different
      if (_prevBlobUrls[blobVar] && _prevBlobUrls[blobVar] !== url) {
        try { URL.revokeObjectURL(_prevBlobUrls[blobVar]); } catch (e) {}
      }
      _prevBlobUrls[blobVar] = url;
      document.body.style.setProperty(blobVar, `url("${url}")`);
      return;
    }
    
  }

  convertCssDataUrlVarToBlob('--tilesetsprite');
  convertCssDataUrlVarToBlob('--worldbackgroundsprite');
  convertCssDataUrlVarToBlob('--playersprite');

// WALK SOUND SETUP
  convertCssDataUrlVarToBlob('--walksound');

  // single AudioContext and decoded buffer, HTMLAudio fallback
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  let walkBuffer = null;
  let walkSound = null;

  function updateWalkSoundFromBlob() {
    const url = _stripUrlWrapper(getComputedStyle(document.body).getPropertyValue('--blob_walksound'));
    walkSound = new Audio(url);
    walkSound.preload = 'auto';
    // decode only once into AudioBuffer reuseable by AudioContext
    fetch(url).then(r => r.arrayBuffer()).then(ab => audioCtx.decodeAudioData(ab)).then(buf => { walkBuffer = buf; });
  }

  updateWalkSoundFromBlob();

  function playWalkSound(){
    if (walkBuffer){
      const s = audioCtx.createBufferSource(); s.buffer = walkBuffer; s.connect(audioCtx.destination); s.start();
      return;
    }
    if (walkSound){ try{ walkSound.currentTime=0; walkSound.play().catch(()=>{}); }catch(e){} }
  }

// CANVAS LEVEL SETUP
  const levelCtx = levelCanvas ? levelCanvas.getContext('2d') : null;
  let tilesetImage = null;

  function setupLevelCanvas() {
    const tilesetUrl = _stripUrlWrapper( // obtain blob: URL for tileset
      getComputedStyle(document.body).getPropertyValue('--blob_tilesetsprite')
    );

    if (!tilesetImage) tilesetImage = new Image(); // reuse current Image object if url unchanged

    tilesetImage.onload = () => { // set up load/error handlers and begin loading the tileset
      redrawLevelCanvas();
    };
    tilesetImage.onerror = () => { alert('Failed to load tileset image: ' + tilesetUrl);};
    
    tilesetImage.src = tilesetUrl; // begin loading the tileset image
  }

  function redrawLevelCanvas() {

    const cols = parseInt(getval('cols')) || 16;
    const rows = parseInt(getval('rows')) || 16;

    // set canvas size to current level size if different
    if (levelCanvas.width !== cols * 16 || levelCanvas.height !== rows * 16) {
      levelCanvas.width = cols * 16;
      levelCanvas.height = rows * 16;
    }

    levelCtx.clearRect(0, 0, levelCanvas.width, levelCanvas.height); // clear canvas

    // read and parse --levelstate into tokens, supporting ".,." as empty cells
    const rawLevelState = (getComputedStyle(document.documentElement).getPropertyValue('--levelstate') || '').trim();
    const levelstate = String(rawLevelState).replace(/^['"]|['"]$/g,'').trim();
    const tokens = levelstate.length ? levelstate.split(/\s+/).filter(Boolean) : [];

    // map tokens -> either [tc,tr] or null for ".,."
    const parsedPairs = tokens.map(t => {
      const tok = String(t).trim();
      if (tok === '.,.') return null;
      const m = tok.match(/^(-?\d+)\s*,\s*(-?\d+)$/);
      if (m) return [parseInt(m[1], 10), parseInt(m[2], 10)];
      return null;
    });

    // build tiles array of length cols*rows; use null for "empty" tiles (missing entries)
    const total = cols * rows;
    const tiles = new Array(total);
    for (let i = 0; i < total; i++) {
      tiles[i] = (i < parsedPairs.length) ? parsedPairs[i] : null;
    }

    // draw each cell using the tiles array (source tile coords * 16)
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const idx = r * cols + c;
        const tile = tiles[idx];
        if (!tile) {
          // treat missing/empty tile as transparent: clear that area of the canvas
          levelCtx.clearRect(c * 16, r * 16, 16, 16);
          continue;
        }
        const [tc = 0, tr = 0] = tile;
        const sx = tc * 16;
        const sy = tr * 16;
        levelCtx.drawImage(tilesetImage, sx, sy, 16, 16, c * 16, r * 16, 16, 16);
      }
    }
  }

  setupLevelCanvas(); // initial render

// AUDIO PLAYBACK
  function playWalkSound() {
    performance.mark('walkSoundStart');
    const a = walkSound;
    if (!a) return;
    try { a.currentTime = 0; } catch (e) { /* ignore read-only currentTime */ }
    const p = a.play && a.play();
    if (p && p.catch) p.catch(() => { /* ignore play promise errors (autoplay etc.) */ });
  }

// MOVEMENT HANDLING
  const KEY_MAP = {
    'arrowup': 'up', 'w': 'up', 'f': 'up',
    'arrowdown': 'down', 's': 'down',
    'arrowleft': 'left', 'a': 'left', 'r': 'left',
    'arrowright': 'right', 'd': 'right', 't': 'right'
  };

  const DIR_MAP = {
    up:    { dx: 0, dy: -1, dir: 0 },
    down:  { dx: 0, dy:  1, dir: 2 },
    left:  { dx: -1, dy: 0, dir: 1 },
    right: { dx:  1, dy: 0, dir: 3 }
  };

  const keysHeld = new Set();

  // simple helpers for wall checks
  function getWallsSet() {
    const raw = getComputedStyle(document.documentElement).getPropertyValue('--walls') || '';
    const cleaned = String(raw).trim().replace(/^['"]|['"]$/g, '');
    return new Set(cleaned.length ? cleaned.split(/\s+/).filter(Boolean) : []);
  }
  
  function getLevelTileAt(cx, ry) {
    const cols = parseInt(getval('cols')) || 16;
    const rows = parseInt(getval('rows')) || 16;
    const raw = getval('levelstate') || '';
    const levelstate = String(raw).replace(/^['"]|['"]$/g, '').trim();
    const tokens = levelstate.length ? levelstate.split(/\s+/).filter(Boolean) : [];
    const idx = ry * cols + cx;
    if (idx < 0 || idx >= cols * rows) return null;
    const t = tokens[idx] || '.,.';
    if (t === '.,.') return null;
    const m = String(t).trim().match(/^(-?\d+)\s*,\s*(-?\d+)$/);
    if (!m) return null;
    return [parseInt(m[1], 10), parseInt(m[2], 10)];
  }
  
  function isWallAt(cx, ry) {
    const tile = getLevelTileAt(cx, ry);
    if (!tile) return false;
    return getWallsSet().has(`${tile[0]},${tile[1]}`);
  }

  function inputHasFocus() {
    const el = document.activeElement;
    if (!el) return false;
    const tag = el.tagName;
    if (tag === 'INPUT' || tag === 'TEXTAREA' || el.isContentEditable) return true;
    return false;
  }

  window.addEventListener('keydown', (e)=>{
    if (inputHasFocus()) return;
    if (!e.repeat){
      const k = (e.key||'').toLowerCase();
      const dir = KEY_MAP[k];
      if (dir){ keysHeld.add(dir); return; }
    }
    if (e.code==='Space' || (e.key||'').toLowerCase()==='z' || e.key==='Enter') handleInteract();
  });
  window.addEventListener('keyup', e => { const dir = KEY_MAP[(e.key||'').toLowerCase()]; if(dir) keysHeld.delete(dir); });

  function clearInputState() { // clear on events where keyup lost
    if (keysHeld.size) keysHeld.clear();
  } 
  window.addEventListener('blur', clearInputState);
  window.addEventListener('focus', clearInputState);

  setInterval(() => { // 60 FPS game loop START
    const currentCols = parseInt(getval('cols')) || 16;
    const currentRows = parseInt(getval('rows')) || 16;

    if (!moving){ // wait until arrival
      const held = Array.from(keysHeld); // iterate keysHeld from most recent to oldest
      for (let i = held.length - 1; i >= 0; i--) {
        const d = held[i];
        const mv = DIR_MAP[d];
        if (!mv) continue;
        const newX = clamp(x + mv.dx, 0, currentCols - 1);
        const newY = clamp(y + mv.dy, 0, currentRows - 1);
        if (newX === x && newY === y) continue;
        // if destination is a wall, do not move — update facing only
        if (isWallAt(newX, newY)) {
          facing = mv.dir;
          continue;
        }
        moving = true;
        x = newX; y = newY;
        facing = mv.dir;
        try { playWalkSound(); } catch (e) { /* ignore */ } // play a step sound when a move begins
        break;
      }
    }

    const dx = x - visx;
    const dy = y - visy;
    if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) { // if visually close, snap and stop
      visx = x;
      visy = y;
      moving = false;
    } else { // else move closer
      visx += Math.sign(dx) * 0.05;
      visy += Math.sign(dy) * 0.05;
    }

    document.body.style.setProperty('--visx', visx);
    document.body.style.setProperty('--visy', visy);

    // frame y is the 4 facing directions
    let frameY = facing * 100;
    document.body.style.setProperty('--playerspriteframey', `${frameY}%`);

    // frame x is the 3 cycle walking animation
    const walkcycle = [1,0,1,2];
    let animframe = 0;
    if (facing === 1 || facing === 3) { // right or left
      animframe = Math.floor(visx * 2) % walkcycle.length;
    } else {
      animframe = Math.floor(visy * 2) % walkcycle.length;
    }
    let frameX = walkcycle[animframe] * -100;
    document.body.style.setProperty('--playerspriteframex', `${frameX}%`);

    // calculate facing tile coords
    const dxFace = (facing === 3 ? 1 : 0) - (facing === 1 ? 1 : 0);
    const dyFace = (facing === 2 ? 1 : 0) - (facing === 0 ? 1 : 0);
    tilefacingx = clamp(x + dxFace, 0, currentCols - 1);
    tilefacingy = clamp(y + dyFace, 0, currentRows - 1);

    //background scrolling
    bgPosX = bgPosX + parseFloat(getval('backgroundscrollspeedx'));
    bgPosY = bgPosY + parseFloat(getval('backgroundscrollspeedy'));
    world.style.backgroundPosition = `${bgPosX}px ${bgPosY}px`;

  }, 16); // 60 FPS game loop END

//INTERACTION HANDLER
  const instructions = document.getElementById('instructions');
  function openLink(url) {
    try { window.open(url, '_blank'); } catch (e) { 
      instructions.querySelector('[data-yumelinks-added]')?.remove();
      instructions.insertAdjacentHTML('beforeend',`<span data-yumelinks-added><br><a href="${url}" target="_blank" rel="noopener noreferrer">iframe doesn't allow-popups, copy this link: ${url}</a></span>`);
    }
  }

  function handleInteract() {
    const raw = getval('links') || '';
    let s = String(raw).trim();
    if ((s[0] === '"' && s[s.length - 1] === '"') || (s[0] === "'" && s[s.length - 1] === "'")) s = s.slice(1, -1);
    s = s.replace(/\\r?\\n/g, '\n');

    const lines = s.split('\\n');

    const coordToken = `${tilefacingx},${tilefacingy}`;
    const esc = coordToken.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const coordRegex = new RegExp('(?:^|\\s)'+esc+'(?:\\s|$)');

    const urlRegex = /\bhttps?:\/\/[^\s]+/i;

    for (const rawLine of lines) {
      const line = String(rawLine || '');
      if (!coordRegex.test(line)) continue; // only consider lines that contain coord

      // prefer URL after the matched coord token on the same line
      const m = line.match(coordRegex);
      const after = line.slice((m.index || 0) + m[0].length);
      const afterUrl = after.match(urlRegex);
      if (afterUrl) { openLink(afterUrl[0]); return; }

      // fallback: any url anywhere on the same line
      const anyUrl = line.match(urlRegex);
      if (anyUrl) { openLink(anyUrl[0]); return; }
    }
  }

</script>


<!-- 
--- DELETE BELOW HERE AND CLOSE HTML TO REMOVE  --- 
--- EDITOR FROM FILE, MODDING IS NICE THOUGH :) ---
--- --- --- --- --- --- --- --- --- --- --- --- ---
.     .    ▗▄▄▄▖▗▄▄▄ ▗▄▄▄▖▗▄▄▄▖▗▄▖ ▗▄▄▖ .         .
.  x       ▐▌   ▐▌  █  █    █ ▐▌ ▐▌▐▌ ▐▌    x     .
.   . x    ▐▛▀▀▘▐▌  █  █    █ ▐▌ ▐▌▐▛▀▚▖       x  .
.       .  ▐▙▄▄▖▐▙▄▄▀▗▄█▄▖  █ ▝▚▄▞▘▐▌ ▐▌      .   .
--- --- --- --- --- --- --- --- --- --- --- --- ---
--- THANK YOU TO ANYONE WHO HELPS FIX THIS JANK -->

<!-- EDITOR HTML -->
<button id="toggleMenu" type="button" tabindex="0" style="z-index:10;" aria-label="Toggle menu">Menu</button>
<div class="menu" id="menu">
  <h2>Yumelinks</h2>
  <button id="saveButton" type="button">Save game (do this often there is no autosave)</button>
  <br>
  <label for="sourceHtmlInput">if cannot save try uploading original HTML here:</label>
  <input id="sourceHtmlInput" type="file" accept=".html,text/html" />
  <br><br>

  <label for="colsInput"><b>Columns</b>: max 16:</label>
  <input id="colsInput" type="number" min="4" max="16" step="1" value="16" style="width:80px" />
  <label for="rowsInput" style="margin-left:8px;"><b>Rows</b>: max 16:</label>
  <input id="rowsInput" type="number" min="4" max="16" step="1" value="16" style="width:80px" />
  <br><br>

  <label for="tilesetInput"><b>Tileset</b>: 16x16 grid, max 20 KiB, max 1024px</label>
  <input id="tilesetInput" type="file" accept="image/*" onchange=
    "if(this.files&&this.files[0]){const f=this.files[0];if(f.size>20480){alert('Tileset image must be 20 KiB or smaller');this.value='';}else{const url=URL.createObjectURL(f);const img=new Image();img.onload=()=>{
    if(img.width>1024||img.height>1024){alert('Tileset image must be 1024x1024 or smaller');this.value='';}URL.revokeObjectURL(url);};img.onerror=()=>{alert('Failed to read tileset image');this.value='';URL.revokeObjectURL(url);};img.src=url;}}"/>
  <br>
  <label for="playerInput"><b>Player spritesheet</b>: 4x4 grid, max 20 KiB, max 512px</label>
  <input id="playerInput" type="file" accept="image/*" onchange=
    "if(this.files&&this.files[0]){const f=this.files[0];if(f.size>20480){alert('Player image must be 20 KiB or smaller');this.value='';}else{const url=URL.createObjectURL(f);const img=new Image();img.onload=()=>{
    if(img.width>512||img.height>512){alert('Player image must be 512x512 or smaller');this.value='';}URL.revokeObjectURL(url);};img.onerror=()=>{alert('Failed to read player image');this.value='';URL.revokeObjectURL(url);};img.src=url;}}"/>
  <br>
  <label for="backgroundInput"><b>Background image</b>: max 20 KiB, max 1024px</label>
  <input id="backgroundInput" type="file" accept="image/*" onchange=
    "if(this.files&&this.files[0]){const f=this.files[0];if(f.size>20480){alert('Background image must be 20 KiB or smaller');this.value='';}else{const url=URL.createObjectURL(f);const img=new Image();img.onload=()=>{
    if(img.width>1024||img.height>1024){alert('Background image must be 1024x1024 or smaller');this.value='';}URL.revokeObjectURL(url);};img.onerror=()=>{alert('Failed to read background image');this.value='';URL.revokeObjectURL(url);};img.src=url;}}"/>
  <br><br>

  <label for="backgroundSize"><b>Background size</b>:</label>
  <input id="backgroundSize" type="number" step="10" value="100" style="width:80px" />
  <br>
  <label for="backgroundSpeedX"><b>Background speed</b> X:</label>
  <input id="backgroundSpeedX" type="number" step="0.1" value="0" style="width:80px" />
  <label for="backgroundSpeedY" style="margin-left:8px;" aria-label="Background scroll Y"> Y:</label>
  <input id="backgroundSpeedY" type="number" step="0.1" value="0" style="width:80px" />
  <br><br>

  <label for="walksoundInput"><b>Walk sound</b>: max 20 KiB:</label>
  <input id="walksoundInput" type="file" accept="audio/*" onchange=
    "if(this.files && this.files[0] && this.files[0].size > 20480){ alert('Walk sound must be 20 KiB or smaller.'); this.value = ''; }" />
  <br><br>

  <label for="startX"><b>Player start</b> X:</label>
  <input id="startX" type="number" min="0" step="1" value="2" style="width:80px" />
  <label for="startY" style="margin-left:8px;" aria-label="Player start Y">Y:</label>
  <input id="startY" type="number" min="0" step="1" value="2" style="width:80px" />
  <p>use url parameters x and y to override start position when linking to your dream for example: mydream.html?x=2&y=5</p>
  <br><br>
  

  <p><b>Tilemap:</b> reclick selected tile to toggle wall</p>
  <label for="selectedCoords">Selected:</label>
  <span id="selectedCoords">none</span>
  <div id="preview" class="tile-preview" title="selected tile preview"></div>
  <button id="eraser" type="button" aria-label="eraser">eraser</button>
  <button id="clearselection" type="button" aria-label="clear selection">clear selection</button>
  <div id="palette" class="palette" aria-label="tileset-palette"></div>
  <button id="cleartilemap" type="button" aria-label="clear level"><b style="text-shadow: 0 1px 1px rgba(255, 0, 0, 0.5);">!! CLEAR</b> level</button>
  <button id="matchtilemap" type="button" aria-label="match level to tilemap"><b style="text-shadow: 0 1px 1px rgba(255, 0, 0, 0.5);">!! RESET</b> level to match tilemap</button>
  <br><br>

  <label for="links"><b>Link tiles</b>: enter string of coords followed by link <br> eg. 0,2 1,2 https://example.com</label>
  <textarea id="links" rows="7" style="resize: vertical;"></textarea>
  <br>

  <label for="debugBox" style="margin-top:12px;display:block;"><b>Debug Output</b>:</label>
  <textarea id="debugBox" rows="3" readonly style="resize: none;">debug output</textarea>
  <br>

  <h6>this program is CC0 public domain, as empire falls may the new dream be to share</h6>
</div>

<!-- EDITOR STYLES -->
<style>
  button, input, textarea {
    outline: none;
    font-size: 1rem;
  }
  button:focus, input:focus, textarea:focus {
    outline: 3px solid rgb(255, 0, 0);
  }
  .cell:focus {
    outline: 2px solid rgba(0, 0, 0, 0.048);
  }
  #toggleMenu { 
    position: fixed;
    top: 5px;
    right: 5px;
    left: auto;
  }
  .menu {
    display:none;
    position: absolute;
    right: 0px;
    left: auto;
    max-width: 512px;
    background: rgba(255, 255, 255, 0.8);
    max-height: 100vh;
    overflow-y: scroll;
    padding: 8px;
  }
  .palette {
    display: flex;
    flex-direction: column;
    background: rgba(0,0,0,0.05);
    margin-top: 8px;
    width: 100%;
    aspect-ratio: 1 / 1;
    background-image: var(--blob_tilesetsprite);
    background-repeat: no-repeat;
    background-size: 100%;
  }
  .palette:focus-within { /* show palette has focus */
    background-color: rgba(255, 0, 0, 0.06);
    box-shadow: 0 0 0 3px rgba(255, 0, 0, 0.12);
    border-radius: 4px;
    outline: none;
  }
  .palette-row { /* arranges tiles in a row */
    display: flex;
    height: calc(100% / 16);
  }
  .tile { /* radio button array for selecting tiles */
    cursor: pointer;
    border: 1px solid transparent;
    width: calc(100% / 16);
    height: 100%;
  }
  .tile:checked { /* show selection on radio checked */
    border-color: #f00;
    outline: 2px solid rgba(255,0,0,0.25);
  }
  .tile-preview {
    display:inline-block;
    vertical-align: middle;
    width: 28px;
    height: 28px;
    margin-left: 8px;
    background-image: var(--blob_tilesetsprite);
    background-size: calc(100% * 16) calc(100% * 16);
    border: 1px solid #999;
  }
  #links, #debugBox {
    width: calc(100% - 12px);
    font-family: monospace;
    font-size: 0.8rem;
    margin-top: 6px;
  }
  .wall {
    background-color: rgba(138, 54, 54, 0.2);
    border: 2px dashed rgba(138, 54, 54, 0.9);
  }

</style>

<script> // EDITOR LOGIC
  const palette = document.getElementById('palette');
  const preview = document.getElementById('preview');
  const selectedCoords = document.getElementById('selectedCoords');

  let selected = null; // {c, r}

// MENU TOGGLE: show/hide menu on button press
  const menu = document.getElementById('menu');
  const toggleMenuBtn = document.getElementById('toggleMenu');
  toggleMenuBtn.addEventListener('click', () => {
    if (menu.style.display === 'none' || getComputedStyle(menu).display === 'none') {
      menu.style.display = 'block';
    } else {
      menu.style.display = 'none';
    }
  });

// ASSET UPLOADS: upload sprites are converted to data:URLs and set as <html> CSS vars
  const tilesetInput = document.getElementById('tilesetInput');
  const backgroundInput = document.getElementById('backgroundInput');
  const playerInput = document.getElementById('playerInput');

  function fileToDataURL(file, cb) {
    const fr = new FileReader();
    fr.onload = () => cb(fr.result);
    fr.onerror = () => cb(null);
    fr.readAsDataURL(file);
  }

  tilesetInput.addEventListener('change', (ev) => {
    const f = ev.target.files && ev.target.files[0];
    if (!f) return;
    fileToDataURL(f, (dataUrl) => {
      if (!dataUrl) return;
      document.documentElement.style.setProperty('--tilesetsprite', `url("${dataUrl}")`);
      // convert CSS data: URL into a blob: URL for runtime use and revocation
      convertCssDataUrlVarToBlob('--tilesetsprite');
      if (debugBox) debugBox.value = dataUrl;
    });
  });

  backgroundInput.addEventListener('change', (ev) => {
    const f = ev.target.files && ev.target.files[0];
    if (!f) return;
    fileToDataURL(f, (dataUrl) => {
      if (!dataUrl) return;
      document.documentElement.style.setProperty('--worldbackgroundsprite', `url("${dataUrl}")`);
      // convert CSS data: URL into a blob: URL for runtime use and revocation
      convertCssDataUrlVarToBlob('--worldbackgroundsprite');
      if (debugBox) debugBox.value = dataUrl;
    });
  });

  playerInput.addEventListener('change', (ev) => {
    const f = ev.target.files && ev.target.files[0];
    if (!f) return;
    fileToDataURL(f, (dataUrl) => {
      if (!dataUrl) return;
      document.documentElement.style.setProperty('--playersprite', `url("${dataUrl}")`);
      // convert CSS data: URL into a blob: URL for runtime use and revocation
      convertCssDataUrlVarToBlob('--playersprite');
      if (debugBox) debugBox.value = dataUrl;
    });
  });

// WALK SOUND UPLOAD uploaded walk sound file is converted to data:URL and set as --walksound CSS var
  const walksoundInput = document.getElementById('walksoundInput');
  if (walksoundInput) {
    walksoundInput.addEventListener('change', (ev) => {
      const f = ev.target.files && ev.target.files[0];
      if (!f) return;
      fileToDataURL(f, (dataUrl) => {
        if (!dataUrl) return;
        // set CSS var so saved HTML picks it up
        document.documentElement.style.setProperty('--walksound', `url("${dataUrl}")`);
        // update runtime Audio object
        convertCssDataUrlVarToBlob('--walksound')
        updateWalkSoundFromBlob();
        if (debugBox) debugBox.value = 'Walk sound loaded';
      });
    });
  }

  let backgroundSpeedXInput = document.getElementById('backgroundSpeedX');
  let backgroundSpeedYInput = document.getElementById('backgroundSpeedY');
  backgroundSpeedXInput.value = parseFloat(getval('backgroundscrollspeedx'));
  backgroundSpeedYInput.value = parseFloat(getval('backgroundscrollspeedy'));
  backgroundSpeedXInput.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value) || 0;
    document.documentElement.style.setProperty('--backgroundscrollspeedx', v);
  });
  backgroundSpeedYInput.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value) || 0;
    backgroundScrollSpeedY = v;
    document.documentElement.style.setProperty('--backgroundscrollspeedy', v);
  });

  let backgroundSizeInput = document.getElementById('backgroundSize');
  let bgSize = parseFloat(rootStyle.getPropertyValue('--backgroundsize')) || 100;
  backgroundSizeInput.value = String(bgSize);
  backgroundSizeInput.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value) || 100;
    bgSize = v;
    document.documentElement.style.setProperty('--backgroundsize', `${v}%`);
  });

// START POSITION CONTROLS: allow user to change --startx / --starty
  const startXInput = document.getElementById('startX');
  const startYInput = document.getElementById('startY');
  startXInput.value = parseFloat(getval('startx')) || 2;
  startYInput.value = parseFloat(getval('starty')) || 2;
  startXInput.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value) || 0;
    document.documentElement.style.setProperty('--startx', v);
  });
  startYInput.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value) || 0;
    document.documentElement.style.setProperty('--starty', v);
  });

// BUILD DRAWING GRID
  const grid = document.getElementById('grid');
  grid.innerHTML = '';
  // create a static 16x16 accessible grid of buttons (cells) for later drawing interactions
  const STATIC_COLS = 16;
  const STATIC_ROWS = 16;
  for (let r = 0; r < STATIC_ROWS; r++) {
    for (let c = 0; c < STATIC_COLS; c++) {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'cell';
      btn.setAttribute('role', 'button');
      btn.setAttribute('aria-label', `cell ${c},${r}`);
      btn.tabIndex = -1;
      btn.title = `cell ${c},${r}`;
      btn.dataset.col = String(c);
      btn.dataset.row = String(r);
      grid.appendChild(btn);
    }
  }

// GRID SIZE CONTROLS: allow user to change --cols / --rows then rebuilds grid

  function levelsizechange(oldCols, oldRows, newCols, newRows) {
    oldCols = parseInt(oldCols, 10) || 0;
    oldRows = parseInt(oldRows, 10) || 0;
    newCols = parseInt(newCols, 10) || 0;
    newRows = parseInt(newRows, 10) || 0;

    const oldTotal = oldCols * oldRows;

    const raw = getval('levelstate') || '';
    let tokens = String(raw).replace(/^['"]|['"]$/g, '').trim()
                      .split(/\s+/).filter(Boolean);

    // normalize to old grid size
    while (tokens.length < oldTotal) tokens.push('.,.');
    if (tokens.length > oldTotal) tokens = tokens.slice(0, oldTotal);

    // build new grid by copying tokens that remain in bounds (drops removed columns)
    const newTokens = [];
    for (let r = 0; r < newRows; r++) {
      for (let c = 0; c < newCols; c++) {
        const oldIdx = r * oldCols + c;
        newTokens.push(oldIdx < tokens.length ? tokens[oldIdx] : '.,.');
      }
    }

    const newState = newTokens.join(' ');
    document.documentElement.style.setProperty('--levelstate', newState);
    setupLevelCanvas();
  }


  const colsInput = document.getElementById('colsInput');
  const rowsInput = document.getElementById('rowsInput');
  if (colsInput) {
    colsInput.value = getval('cols') || 16;
    colsInput.addEventListener('input', (e) => {
      let v = parseInt(e.target.value, 10) || 1;
      v = Math.max(1, Math.min(64, v));
      levelsizechange(getval('cols'), getval('rows'), v, getval('rows'));
      document.documentElement.style.setProperty('--cols', v);
    });
  }
  if (rowsInput) {
    rowsInput.value = getval('rows') || 16;
    rowsInput.addEventListener('input', (e) => {
      let v = parseInt(e.target.value, 10) || 1;
      v = Math.max(1, Math.min(64, v));
      ROWS = v;
      levelsizechange(getval('cols'), getval('rows'), getval('cols'), v);
      document.documentElement.style.setProperty('--rows', v);
    });
  }

// EDITOR CLEAR BUTTON: clears selected tile
  const clearselectionBtn = document.getElementById('clearselection');
  clearselectionBtn.addEventListener('click', () => {
    selected = null;
    selectedCoords.textContent = 'none';
    preview.style.backgroundPosition = `-100% -100%`; // out of view
    const prev = palette.querySelector('.tile.selected');
    if (prev) prev.classList.remove('selected');
  });

// EDITOR ERASER BUTTON: selects eraser (null)
  const eraserBtn = document.getElementById('eraser');
  eraserBtn.addEventListener('click', () => {
    selected = { c: -1, r: -1 }; // blank tile symbol
    selectedCoords.textContent = 'eraser';
    preview.style.backgroundPosition = `-100% -100%`; // out of view
    const prev = palette.querySelector('.tile.selected');
    if (prev) prev.classList.remove('selected');
  });

// EDITOR MATCH TILEMAP BUTTON: sets levelstate to match tilemap
  const matchtilemapBtn = document.getElementById('matchtilemap');
  matchtilemapBtn.addEventListener('click', () => {
    const cols = parseInt(getval('cols')) || 16;
    const rows = parseInt(getval('rows')) || 16;
    const total = cols * rows;
    const tokens = [];
    for (let i = 0; i < total; i++) {
      const c = i % cols;
      const r = Math.floor(i / cols);
      tokens.push(`${c},${r}`);
    }
    const newState = tokens.join(' ');
    document.documentElement.style.setProperty('--levelstate', newState);
    redrawLevelCanvas();
  });

// EDITOR CLEAR TILEMAP BUTTON: clears entire tilemap
  const clearlevelBtn = document.getElementById('cleartilemap');
  clearlevelBtn.addEventListener('click', () => {
    const cols = parseInt(getval('cols')) || 16;
    const rows = parseInt(getval('rows')) || 16;
    const total = cols * rows;
    const tokens = [];
    for (let i = 0; i < total; i++) {
      tokens.push('.,.');
    }
    const newState = tokens.join(' ');
    document.documentElement.style.setProperty('--levelstate', newState);
    redrawLevelCanvas();
  });

// EDITOR: sets up tileset palette and selection handling
  palette.innerHTML = '';
  for (let r = 0; r < 16; r++) {
    const rowEl = document.createElement('div');
    rowEl.className = 'palette-row';
    rowEl.setAttribute('role', 'group');
    rowEl.setAttribute('aria-label', `tileset row ${r}`);
    //rowEl.tabIndex = 0; // Tab / Shift+Tab will move between rows

    for (let c = 0; c < 16; c++) {
      const input = Object.assign(document.createElement('input'), { type: 'radio', name: 'paletteTile' });
      input.id = `tile-${r}-${c}`;
      input.dataset.col = String(c);
      input.dataset.row = String(r);
      input.value = `${c},${r}`;
      input.className = 'tile'; // used for sizing / focus / selection visuals, NOT for per-cell background
      input.setAttribute('aria-label', `tile ${c},${r}`);
      input.title = `tile ${c},${r}`;
      // keep radios out of the Tab order so Tab navigates rows only
      //input.tabIndex = -1;

      // when a radio becomes checked update the selected state and preview
      input.addEventListener('change', () => {
        if (!input.checked) return;
        selected = { c, r };
        selectedCoords.textContent = `${c},${r}`;
        // compute preview background-position from coords (no per-input background required)
        preview.style.backgroundPosition = `${(100/15*c)}% ${(100/15*r)}%`;
        // keep legacy .selected class for any other code that expects it
        const prev = palette.querySelector('.tile.selected');
        if (prev) prev.classList.remove('selected');
        input.classList.add('selected');
      });

      // clicking an already-selected radio toggles wall state for that tile
      input.addEventListener('click', (ev) => {
        // click runs before 'change' — use existing .selected class to detect pre-click checked state
        const wasSelected = input.classList.contains('selected');
        if (!wasSelected) return; // normal selection, handled by change handler
        ev.preventDefault(); // don't try to change radio state
        const key = `${c},${r}`;
        const raw = getComputedStyle(document.documentElement).getPropertyValue('--walls') || '';
        const cleaned = String(raw).trim().replace(/^['"]|['"]$/g, '');
        const tokens = cleaned.length ? cleaned.split(/\s+/).filter(Boolean) : [];
        const set = new Set(tokens);
        if (set.has(key)) set.delete(key); else set.add(key);
        document.documentElement.style.setProperty('--walls', Array.from(set).join(' '));
        updateWallsUI();
        // ensure radio remains visually selected
        input.checked = true;
        input.classList.add('selected');
      });
      rowEl.appendChild(input); // append each radio into the current row element (so rows are focusable)
    }
  
    palette.appendChild(rowEl);
  }

  function updateWallsUI() {
    const raw = getComputedStyle(document.documentElement).getPropertyValue('--walls') || '';
    const cleaned = String(raw).trim().replace(/^['"]|['"]$/g, '');
    const tokens = cleaned.length ? cleaned.split(/\s+/).filter(Boolean) : [];
    const wallSet = new Set(tokens);
    document.querySelectorAll('input[name="paletteTile"]').forEach(input => {
      const key = `${input.dataset.col},${input.dataset.row}`;
      if (wallSet.has(key)) {
        input.classList.add('wall');
        input.setAttribute('aria-pressed', 'true');
      } else {
        input.classList.remove('wall');
        input.setAttribute('aria-pressed', 'false');
      }
    });
  }

  updateWallsUI()


// DRAWING STUFF
  function changeGridTile(c, r) {
    if (!selected) return;
    const cols = parseInt(getval('cols')) || 16;
    const rows = parseInt(getval('rows')) || 16;
    c = clamp(parseInt(c) || 0, 0, cols - 1);
    r = clamp(parseInt(r) || 0, 0, rows - 1);

    // use global `selected` if available; if null -> treat as empty
    let tileToSet = null;
    if (typeof selected !== 'undefined' && selected !== null) {
      const sc = parseInt(selected.c, 10);
      const sr = parseInt(selected.r, 10);
      // if selection uses the eraser sentinel (-1) treat as empty
      if (sc === -1 || sr === -1) {
        tileToSet = null;
      } else {
        tileToSet = [isNaN(sc) ? 0 : sc, isNaN(sr) ? 0 : sr];
      }
    } else {
      tileToSet = null; // empty cell represented as null -> serialized as ".,."
    }

    // read existing levelstate and parse tokens (support ".,." as empty)
    const raw = getval('levelstate') || '';
    const levelstate = String(raw).replace(/^['"]|['"]$/g, '').trim();
    const tokens = levelstate.length ? levelstate.split(/\s+/).filter(Boolean) : [];

    const parsedPairs = tokens.map(t => {
      if (t === '.,.') return null;
      const m = String(t).trim().match(/^(-?\d+)\s*,\s*(-?\d+)$/);
      if (m) return [parseInt(m[1], 10), parseInt(m[2], 10)];
      return null;
    });

    // build full tiles array (cols*rows), defaulting missing cells to null (empty)
    const total = cols * rows;
    const tiles = new Array(total);
    for (let i = 0; i < total; i++) {
      tiles[i] = (i < parsedPairs.length) ? parsedPairs[i] : null;
    }

    // set the single tile (null => empty)
    const idx = r * cols + c;
    tiles[idx] = tileToSet;

    // write back to CSS var using ".,." for empty cells and re-render canvas
    const newState = tiles.map(t => (t === null ? '.,.' : `${t[0]},${t[1]}`)).join(' ');
    document.documentElement.style.setProperty('--levelstate', newState);
    redrawLevelCanvas();
  }

  // Simplified grid paint handler: paint on pointerdown + pointermove while button held.
  window.addEventListener('DOMContentLoaded', attachGridHandler);
  if (document.readyState === 'complete') attachGridHandler();

  function attachGridHandler() {
    const gridEl = document.getElementById('grid');
    if (!gridEl) return;
    let drawing = false;

    // Compute grid coordinates based on pointer position and the current --cols/--rows values.
    function getGridCoordsFromEvent(ev) {
      const rect = gridEl.getBoundingClientRect();
      // support pointer and touch events
      const clientX = (ev.clientX !== undefined) ? ev.clientX : (ev.touches && ev.touches[0] && ev.touches[0].clientX) || 0;
      const clientY = (ev.clientY !== undefined) ? ev.clientY : (ev.touches && ev.touches[0] && ev.touches[0].clientY) || 0;
      const x = clientX - rect.left;
      const y = clientY - rect.top;

      const cols = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cols')) || 16;
      const rows = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--rows')) || 16;

      const cellW = (rect.width || 1) / cols;
      const cellH = (rect.height || 1) / rows;

      const c = clamp(Math.floor(x / cellW), 0, cols - 1);
      const r = clamp(Math.floor(y / cellH), 0, rows - 1);
      return { c, r };
    }

    const paintFromEvent = (ev) => {
      const { c, r } = getGridCoordsFromEvent(ev);
      changeGridTile(c, r);
    };

    gridEl.addEventListener('pointerdown', (ev) => {
      if (ev.button && ev.button !== 0) return;
      drawing = true;
      paintFromEvent(ev);
      // If a tileset control (or anything inside the palette) currently has focus,
      // keep focus there so keyboard selection continues. Otherwise move focus to world.
      const active = document.activeElement;
      const isPaletteFocused = !!(
        active &&
        (active.classList && active.classList.contains('tile') ||
         (typeof active.closest === 'function' && active.closest('.palette')))
      );
      if (!isPaletteFocused) {
        try { world.focus({ preventScroll: true }); } catch (e) { if (world && world.focus) world.focus(); }
      } else {
        // restore focus to the same element to avoid accidental blur side-effects
        try { active.focus({ preventScroll: true }); } catch (e) { try { active.focus(); } catch (err) {} }
      }
    });

    gridEl.addEventListener('pointermove', (ev) => {
      if (!drawing) return;
      paintFromEvent(ev);
    });

    // stop drawing when button released anywhere
    window.addEventListener('pointerup', () => drawing = false);
  }

// LINKS EDITOR: user sets --links
  const linkelement = document.getElementById('links');
  const rawlinks = getval('links') || '';
  // show real newlines in the textarea by converting literal "\n" sequences to actual newlines
  let displayLinks = String(rawlinks).trim().replace(/^['"]|['"]$/g, '');
  displayLinks = displayLinks.replace(/\\n/g, '\n');
  linkelement.value = displayLinks;
  linkelement.addEventListener('input', (e) => {
    let v = String(e.target.value || '').trim();
    // store newlines as the two-character sequence "\n" in the CSS var
    v = v.replace(/\r?\n/g, '\\n');
    v = v.replace(/^['"]|['"]$/g, '');
    document.documentElement.style.setProperty('--links', v);
  });

// DEBUG: shows info updates at 60 fps
  const debugBox = document.getElementById('debugBox');
  setInterval(() => { // 60 FPS game loop START
    debugBox.value =
      `Position: x=${x}, y=${y}\n` +
      `Tile Facing: ${tilefacingx},${tilefacingy}\n` //+
      //`Tileset Selected: ${selected ? `${selected.c},${selected.r}` : 'none'}`
      //`Visual Position:   visx=${visx.toFixed(2)}, visy=${visy.toFixed(2)}\n` +
      //`Keys:     [${Array.from(keysHeld).join(', ')}]\n` +
      //`Moving:   ${moving}\n` +
      //`Facing:   ${facing}\n` +
      //`Animframe: ${animframe.toFixed(2)}\n` +
  }, 64); // 60 FPS game loop END

// SAVE PAGE: saves only opening <html ...> block appending to user uploaded original HTML
  const sourceHtmlInputEl = document.getElementById('sourceHtmlInput');
  const saveButtonEl = document.getElementById('saveButton');
  let ORIGINAL_SOURCE = null;

  // Try to auto-load the original HTML from the current URL or common hints before user upload.
  const candidates = [window.location.href];
  const link = document.querySelector('link[rel="original"], link[rel="source"], link[rel="canonical"]');
  if (link && link.href) candidates.push(link.href);
  if (window.location.pathname && window.location.pathname.endsWith('/')) {
    candidates.push(window.location.href + 'index.html');
  }
  candidates.forEach((url) => {
    fetch(url, { cache: 'no-store' })
      .then(res => {
        if (!res.ok) return null;
        if (ORIGINAL_SOURCE) return null;
        return res.text();
      })
      .then(txt => {
        if (!txt || ORIGINAL_SOURCE) return;
        const startsWithDoctype = /^\s*<!doctype\s+html>/i.test(txt);
        const htmlWithLangAndStyle = /<html[^>]*\blang\s*=\s*['"][^'"]+['"][^>]*\bstyle\s*=\s*['"]/i.test(txt.slice(0, 2000));
        if (startsWithDoctype && htmlWithLangAndStyle) {
          ORIGINAL_SOURCE = txt;
          if (saveButtonEl) saveButtonEl.disabled = false;
          console.info('Original HTML auto-loaded from:', url);
        }
      })
  });

  if (saveButtonEl) saveButtonEl.disabled = true;
  if (sourceHtmlInputEl) {
    sourceHtmlInputEl.addEventListener('change', (ev) => {
      const f = ev.target.files && ev.target.files[0];
      if (!f) {
        ORIGINAL_SOURCE = null;
        if (saveButtonEl) saveButtonEl.disabled = true;
        alert('Original HTML cleared.');
        return;
      }
      const r = new FileReader();
      r.onload = () => {
        const txt = String(r.result || '');
        
        const startsWithDoctype = /^\s*<!doctype\s+html>/i.test(txt); // validate html file, ignoring linebreaks/extra whitespace and allowing single or double quotes for attributes.
        const htmlWithLangAndStyle = /<html[^>]*\blang\s*=\s*['"][^'"]+['"][^>]*\bstyle\s*=\s*['"]/i.test(txt.slice(0, 2000)); // allow any lang value (not forcing "en")

        if (!startsWithDoctype || !htmlWithLangAndStyle) {
          ORIGINAL_SOURCE = null;
          if (saveButtonEl) saveButtonEl.disabled = true;
          alert('Uploaded file does not look like the original HTML. It must start with <!doctype html> and include <html lang=\"...\" style=...> at the top.');
          return;
        }

        ORIGINAL_SOURCE = txt;
        if (saveButtonEl) saveButtonEl.disabled = false;
        alert('Original HTML file loaded successfully. You can now save your changes.');
      };
      r.onerror = () => {
        ORIGINAL_SOURCE = null;
        if (saveButtonEl) saveButtonEl.disabled = true;
        alert('Failed to read uploaded HTML file.');
      };
      r.readAsText(f);
    });
  }

  if (saveButtonEl) {
    saveButtonEl.addEventListener('click', () => {
      if (!ORIGINAL_SOURCE) {
        alert('Please upload the original HTML file before saving.');
        return;
      }

      // build list of CSS custom properties currently set on the <html> element's inline style
      const htmlInlineStyle = document.documentElement.getAttribute('style') || '';
      const varRegex = /(--[a-zA-Z0-9\-_]+)\s*:/g;
      const varsToCapture = [];
      let m;
      while ((m = varRegex.exec(htmlInlineStyle))) {
        if (!varsToCapture.includes(m[1])) varsToCapture.push(m[1]);
      }
      if (varsToCapture.length === 0) {  // if no vars found in inline html style, try to pull defaults from the uploaded original HTML
        const htmlStyleMatch = ORIGINAL_SOURCE.match(/<html[^>]*\bstyle\s*=\s*(['"])([\s\S]*?)\1/i);
        if (htmlStyleMatch && htmlStyleMatch[2]) {
        const htmlStyleText = htmlStyleMatch[2];
        const inlineVarRegex = /(--[a-zA-Z0-9\-_]+)\s*:\s*([^;]+);?/g;
        let mm;
        while ((mm = inlineVarRegex.exec(htmlStyleText))) {
          if (!varsToCapture.includes(mm[1])) varsToCapture.push(mm[1]);
        }
        }
        alert('Unable to determine CSS custom properties to save. Ensure the original HTML contains an inline style on the <html> tag with the variables.'); // if still nothing found, abort save and inform the user
        return;
      }
      const cs = getComputedStyle(document.documentElement);
      const lines = varsToCapture.map(v => `${v}: ${cs.getPropertyValue(v).trim()};`);

      // preserve whatever lang the uploaded file used (fall back to 'en' if not present)
      const langMatch = ORIGINAL_SOURCE.match(/^<html[^>]*\blang\s*=\s*(['"])(.*?)\1/i);
      const langVal = (langMatch && langMatch[2]) ? langMatch[2] : 'en';
      const newHtmlOpen = `<html lang="${langVal}" style='\n${lines.join('\n')}\n'>`;

      // replace the first <html ...> tag wherever it appears (after <!doctype> usually)
      let replaced = ORIGINAL_SOURCE.replace(/<html[^>]*>/i, newHtmlOpen);
      // if no <html> tag was found at all, prepend the new opening tag
      if (replaced === ORIGINAL_SOURCE) replaced = newHtmlOpen + '\n' + ORIGINAL_SOURCE;
      
      const blob = new Blob([replaced], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'yumelinks_saved.html';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);

    });

  }
</script>

</body>
</html>




