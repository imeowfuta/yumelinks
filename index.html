<!doctype html>
<html lang="en"
style='
--cols: 16;
--rows: 16;
--x: 1;
--y: 1;
--backgroundscrollspeedx: 0.5;
--backgroundscrollspeedy: 0.1;
--backgroundsize: 30%;
--customhtml: "0,0 6,2 https://en.wikipedia.org/wiki/Torrent_duck";
--gridstate: "3,0 1,0 2,0 2,0 2,0 2,0 0,0 0,0 1,0 0,0 1,0 0,0 0,0 0,0 1,0 0,0 0,0 0,0 1,0 0,0 0,0 0,0 0,0 0,0 1,0 0,0 1,0 4,0 4,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 1,0 1,0 3,0 1,0";
--tilesetsprite: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEABAMAAACuXLVVAAAAD1BMVEUAAACZmZlmZplmZmYzZpko+ityAAAAAXRSTlMAQObYZgAAAQ9JREFUeNrt1MGRwjAQRFFSaA8JuFECg0hgxeQf0xa2Wba4Iy7/HXzw6ZeqpZPe+KCHRTp9mjapJ1fZbmPxInlSQCgVqa6QquxWw1q8ao0pAamU1CO7Mm23Klt99WJPCMjQJiJSSrtq2Fasi7Wsnw+IV8DbCK8XTRvhi92qypbieslvBNQ+Q+nc+883Ah5aDalX9SkBud/DQ/NOuvd+mxDQQ1JsH0VKNZ4Bt6r7hIAI7TKkrm67arR5J6Cn/STS+wotnavmjDD0J0I+aBM55yn+pw17uNX+N75yDcutSocTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAh/0C3aM3uPegxg0AAAAASUVORK5CYII="); 
--playersprite: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACAAgAAAACs5Sa2AAAAAnRSTlMAAQGU/a4AAAK7SURBVHja7ZfBattAFEXfoMxOwdlo1/6DismuoRNM6CaQCY7QxuBf6KJLQ39thNEuELrwf6iE7FpU9N4LlxlbGIEhEJLN1Z1ziJ2Rxnmm6sgPnUTwFr1Ch5BTBLRDeCip4Ou5AO0QlkSWQRCgHYKXBWQqOCIDgJ4IyJML6WujYx+ICgB07CRRBcBZjf4GzSIRFDjD6VwkDCBjcO3MNWcQEULIBGjakMXCIlCrwA/5nViM7uZOAP0esiZqI2GtQo18iYQV0eVwuVagHcKGFwD2hB+8Dyxe6UadH9zJn0SfseWR4AsFkjYVjLP8sBrXDumNG7kXyGnCYOA9oB45vG8lLO2RD5BHtVeHP0BwD/Ye+5AcHO4Tjt6U0503I0LeCkAmwnwnoOfkDgHAZz1ECAAPs07FWAD41lcqJoICP/sngnYICtxFwakdglfg+CahQ/gk4MwZTu0Q3ELAjaYTEcK9gmpBHNohVLekAjIWNrqQkb7bkAglAwjUcUIgBY50rYwEAC/BPRKsU8C3AB2n27UiWA7ukZA7i8cdHUL0f0L6yF/B69ynHN6P+eGE88O8NADoEJ7mBmDoX2Nh2fctg2cRtUOo+34HgI6d3G4LAHTsZN/zgt9uLSf3+BPmFXC6uy4WfND54e7P65gwMj90Y/ND9hzPD0+hifch63YMZkHmh1nYmx9eFAzi0HfT5oc1LwBsDkwg55gfeJ64fIP5QQCRiO98fvDvYX5YlCPCUkCaEOpHWah7Tu0QAPpgIUIAmPGhlQ4BoOr/QoTAQBZ+dVbFSBiADg5nRsVIGIDVmySCdggrXXDmgtNHAgMjQnPPeduYRGhu5Lrh4A4BAPmFA0Km742Crl2lYxJB4MwTISe9NipQJAxAi4UYCcbLdS1AO4Sl0YfUi6AdgjdlgccdHQLh+I99AanwEtynHN7/JGfMtvZgnCUAAAAASUVORK5CYII=");
--worldbackgroundsprite: url("data:image/jpeg;base64,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");
--walksound: url("data:audio/mpeg;base64,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");
'>

<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>yumelinks</title>

</head>
<body>
  <div class="grid" id="grid"></div>
  <div class="player" id="player"></div>

  <div class="menu" id="menu">

    <p>move: arrows/WASD, interact: z/space</p>

    <label for="sourceHtmlInput">Upload original HTML (required to Save):</label>
    <input id="sourceHtmlInput" type="file" accept=".html,text/html" />
    <label for="saveButton">Save:</label>
    <button id="saveButton" type="button">Save</button>
    <br>

    <label for="tilesetInput">Upload tileset, 16x16 grid, max 20 KiB, max 1024px:</label>
    <input id="tilesetInput" type="file" accept="image/*" onchange=
      "if(this.files&&this.files[0]){const f=this.files[0];if(f.size>20480){alert('Tileset image must be 20 KiB or smaller');this.value='';}else{const url=URL.createObjectURL(f);const img=new Image();img.onload=()=>{
      if(img.width>1024||img.height>1024){alert('Tileset image must be 1024x1024 or smaller');this.value='';}URL.revokeObjectURL(url);};img.onerror=()=>{alert('Failed to read tileset image');this.value='';URL.revokeObjectURL(url);};img.src=url;}}"/>
    <br>

    <label for="playerInput">Upload player sprite frames, 4x4 grid, max 20 KiB, max 512px:</label>
    <input id="playerInput" type="file" accept="image/*" onchange=
      "if(this.files&&this.files[0]){const f=this.files[0];if(f.size>20480){alert('Player image must be 20 KiB or smaller');this.value='';}else{const url=URL.createObjectURL(f);const img=new Image();img.onload=()=>{
      if(img.width>512||img.height>512){alert('Player image must be 512x512 or smaller');this.value='';}URL.revokeObjectURL(url);};img.onerror=()=>{alert('Failed to read player image');this.value='';URL.revokeObjectURL(url);};img.src=url;}}"/>
    <br>

    <label for="walksoundInput">Upload walk sound, max 20 KiB:</label>
    <input id="walksoundInput" type="file" accept="audio/*" onchange=
      "if(this.files && this.files[0] && this.files[0].size > 20480){ alert('Walk sound must be 20 KiB or smaller.'); this.value = ''; }" />
    <br>

    <label for="backgroundInput">Upload background image, max 20 KiB, max 1024px:</label>
    <input id="backgroundInput" type="file" accept="image/*" onchange=
      "if(this.files&&this.files[0]){const f=this.files[0];if(f.size>20480){alert('Background image must be 20 KiB or smaller');this.value='';}else{const url=URL.createObjectURL(f);const img=new Image();img.onload=()=>{
      if(img.width>1024||img.height>1024){alert('Background image must be 1024x1024 or smaller');this.value='';}URL.revokeObjectURL(url);};img.onerror=()=>{alert('Failed to read background image');this.value='';URL.revokeObjectURL(url);};img.src=url;}}"/>
    <br>
    <label for="backgroundSpeedX">Background scroll speed X</label>
    <label for="backgroundSpeedY" style="margin-left:8px;">and Y</label>
    <br>
    <input id="backgroundSpeedX" type="number" step="0.1" value="0" style="width:80px" />
    <input id="backgroundSpeedY" type="number" step="0.1" value="0" style="width:80px" />
    <br>
    <label for="backgroundSize">Background image size:</label>
    <input id="backgroundSize" type="number" step="10" value="100" style="width:80px" />
    <br>

    <label for="colsInput">Columns:</label>
    <input id="colsInput" type="number" min="4" max="64" step="1" value="16" style="width:80px" />
    <label for="rowsInput" style="margin-left:8px;">Rows:</label>
    <input id="rowsInput" type="number" min="4" max="64" step="1" value="16" style="width:80px" />
    <br>
    
    <label>Tileset palette (click a tile to select)</label>
    <div id="palette" class="palette" aria-label="tileset-palette"></div>
    <div class="palette-row">
      <div>
        Selected:
        <span id="selectedCoords">none</span>
      </div>
      <div id="preview" class="tile-preview" title="selected tile preview"></div>
    </div>
    <br>

    <label for="customHTML">enter string of coords followed by link or custom html. eg. 2,4 3,4 https://example.com</label>
    <textarea id="customHTML" rows="7" style="resize: vertical;">2,4 https://example.com</textarea>
    <br>

    <label for="debugBox" style="margin-top:12px;display:block;">Debug Output:</label>
    <textarea id="debugBox" rows="7" readonly style="resize: none;">debug output</textarea>
    <br>

    <h6>CC0 1.0 Universal (CC0 1.0) Public Domain Dedication</h6>

  </div>
  <button id="toggleMenu" type="button">Menu</button>


<script> // // // // // // // // // // SCRIPT // // // // // // // // // //
  const rootStyle = getComputedStyle(document.documentElement);

  let COLS = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cols')) || 16;
  let ROWS = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--rows')) || 16;
  let x = parseFloat(rootStyle.getPropertyValue('--x')) || 2;
  let y = parseFloat(rootStyle.getPropertyValue('--y')) || 2;
  let backgroundScrollSpeedX = parseFloat(rootStyle.getPropertyValue('--backgroundscrollspeedx')) || 0;
  let backgroundScrollSpeedY = parseFloat(rootStyle.getPropertyValue('--backgroundscrollspeedy')) || 0;
  let customhtml = (rootStyle.getPropertyValue('--customhtml') || '').trim();

  let walkSound = null;
  const v = getComputedStyle(document.documentElement).getPropertyValue('--walksound') || '';
  const m = v.match(/url\((['"]?)(.*?)\1\)/);
  if (m && m[2]) {
    try { walkSound = new Audio(m[2]); walkSound.preload = 'auto'; } catch (e) { walkSound = null; }
  }

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const PALETTE_COLS = 16;
  const PALETTE_ROWS = 16;
  const palette = document.getElementById('palette');
  const preview = document.getElementById('preview');
  const selectedCoords = document.getElementById('selectedCoords');
  const grid = document.getElementById('grid');
  const player = document.getElementById('player');

  let visx = x;
  let visy = y;
  let moving = false; // NEW: block new moves until arrival
  let facing = 2; // 0=up,1=right,2=down,3=left
  let tilefacingx = 0;
  let tilefacingy = 0;
  let selected = null; // {c, r}

  document.body.style.setProperty('--visx', visx);
  document.body.style.setProperty('--visy', visy);
  document.body.style.setProperty('--playerspriteframex', '0%');
  document.body.style.setProperty('--playerspriteframey', '0%');

// BLOB PROCCESSING FUNCTIONS

  const _prevBlobUrls = {}; // Blob-url cache for CSS blob vars so we can revoke old blob: URLs when replaced

  function _stripUrlWrapper(cssVal) {
    const mm = String(cssVal).trim().match(/url\((['"]?)(.*?)\1\)/);
    return mm ? mm[2] : cssVal.trim();
  }

  function convertCssDataUrlVarToBlob(baseVar) { // Convert a CSS variable that contains a data into a blob: URL stored in a separate CSS var
    const blobVar = baseVar.replace(/^--/, '--blob_');
    const raw = getComputedStyle(document.documentElement).getPropertyValue(baseVar) || '';
    const val = _stripUrlWrapper(raw);

    if (val.startsWith('data:')) { // If it's a data: URL convert to Blob and create blob: URL
      const [, mime = 'application/octet-stream', base64Flag, payload] =
        String(val).match(/^data:([^;,]+)?(;base64)?,(.*)$/);
      const str = base64Flag ? atob(payload) : decodeURIComponent(payload);
      const blob = new Blob([Uint8Array.from(str, c => c.charCodeAt(0))], { type: mime });

      const url = URL.createObjectURL(blob);
      // revoke previous
      if (_prevBlobUrls[blobVar] && _prevBlobUrls[blobVar] !== url) {
        try { URL.revokeObjectURL(_prevBlobUrls[blobVar]); } catch (e) {}
      }
      _prevBlobUrls[blobVar] = url;
      document.body.style.setProperty(blobVar, `url("${url}")`);
      return;
    }
    
  }

  convertCssDataUrlVarToBlob('--tilesetsprite');
  convertCssDataUrlVarToBlob('--worldbackgroundsprite');
  convertCssDataUrlVarToBlob('--playersprite');

// BUILD GRID
  function buildGrid() {
    grid.innerHTML = '';
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const d = document.createElement('div');
        d.className = 'cell';
        d.style.setProperty('--col', c);
        d.style.setProperty('--row', r);
        d.dataset.col = c;
        d.dataset.row = r;
        grid.appendChild(d);
      }
    }

    const rawGridState = (getComputedStyle(document.documentElement).getPropertyValue('--gridstate') || '').trim();
    let gridstate = String(rawGridState).replace(/^['"]|['"]$/g,'').trim(); // strip surrounding quotes if any

    if (gridstate && /^[\d\s,]+$/.test(gridstate)) { // only allow digits, commas and whitespace (including newlines)
      // parse any digits into an array of number pairs: [[a,b],[c,d],...]
      const nums = (gridstate.match(/\d+/g) || []).map(n => parseInt(n, 10)).filter(n => Number.isFinite(n));
      const parsed = [];
      for (let i = 0; i < nums.length; i += 2) {
        if (i + 1 < nums.length) parsed.push([nums[i], nums[i + 1]]);
      }
      if (parsed.length) {
        for (let r = 0; r < parsed.length; r++) { // fill remaining rows with empty tiles if needed
          const idx = r;
          const cell = grid.querySelector(`.cell[data-col="${idx % COLS}"][data-row="${Math.floor(idx / COLS)}"]`);
          const [tc = 0, tr = 0] = parsed[idx] || [];
          if (cell) cell.style.backgroundPosition = `${(100/15*tc)}% ${(100/15*tr)}%`;
        }
      }
    }
  }
  
  buildGrid()

// AUDIO PLAYBACK

  function playWalkSound() {
    const a = walkSound;
    if (!a) return;
    try { a.currentTime = 0; } catch (e) { /* ignore read-only currentTime */ }
    const p = a.play && a.play();
    if (p && p.catch) p.catch(() => { /* ignore play promise errors (autoplay etc.) */ });
  }

// MOVEMENT HANDLING

  const KEY_MAP = {
    'arrowup': 'up', 'w': 'up', 'f': 'up',
    'arrowdown': 'down', 's': 'down',
    'arrowleft': 'left', 'a': 'left', 'r': 'left',
    'arrowright': 'right', 'd': 'right', 't': 'right'
  };

  const DIR_MAP = {
    up:    { dx: 0, dy: -1, dir: 0 },
    down:  { dx: 0, dy:  1, dir: 2 },
    left:  { dx: -1, dy: 0, dir: 1 },
    right: { dx:  1, dy: 0, dir: 3 }
  };

  const keysHeld = new Set();

  function inputHasFocus() {
    const el = document.activeElement;
    if (!el) return false;
    const tag = el.tagName;
    if (tag === 'INPUT' || tag === 'TEXTAREA' || el.isContentEditable) return true;
    return false;
  }

  window.addEventListener('keydown', (e) => {
    if (inputHasFocus()) return; // block player input while typing
    const k = String(e.key || '').toLowerCase();
    const dir = KEY_MAP[k];
    if (dir) keysHeld.add(dir);
  });
  window.addEventListener('keyup', (e) => {
    if (inputHasFocus()) return; // block player input while typing
    const k = String(e.key || '').toLowerCase();
    const dir = KEY_MAP[k];
    if (dir) keysHeld.delete(dir);
  });

  // movement priority using generic directions
  const PRIORITY = ['up', 'down', 'left', 'right'];

  setInterval(() => { // 30 FPS game loop START
    if (!moving){ // wait until arrival
      for (const d of PRIORITY) {
        if (!keysHeld.has(d)) continue;
        const mv = DIR_MAP[d];
        if (!mv) continue;
        const newX = clamp(x + mv.dx, 0, COLS - 1);
        const newY = clamp(y + mv.dy, 0, ROWS - 1);
        if (newX === x && newY === y) break;
        moving = true;
        x = newX; y = newY;
        facing = mv.dir;
        document.documentElement.style.setProperty('--x', x);
        document.documentElement.style.setProperty('--y', y);
      
      try { playWalkSound(); } catch (e) { /* ignore */ } // play a step sound when a move begins
        break;
      }
    }

    const dx = x - visx;
    const dy = y - visy;
    if (Math.abs(dx) < 0.2 && Math.abs(dy) < 0.2) { // if visually close, snap and stop
      visx = x;
      visy = y;
      moving = false;
    } else { // else move closer
      visx += Math.sign(dx) * 0.1;
      visy += Math.sign(dy) * 0.1;
    }

    document.body.style.setProperty('--visx', visx);
    document.body.style.setProperty('--visy', visy);


    // facing direction framey
    let frameY = facing * 100;
    document.body.style.setProperty('--playerspriteframey', `${frameY}%`);

    // walking animation framex
    const walkcycle = [1,0,1,2];
    let animframe = 0;
    if (facing === 1 || facing === 3) { // right or left
      animframe = Math.floor(visx * 2) % walkcycle.length;
    } else {
      animframe = Math.floor(visy * 2) % walkcycle.length;
    }
    let frameX = walkcycle[animframe] * -100;
    document.body.style.setProperty('--playerspriteframex', `${frameX}%`);

    // calculate facing tile coords
    tilefacingx = (facing === 3 ? 1 : 0) - (facing === 1 ? 1 : 0); // flipped X facing
    tilefacingy = (facing === 2 ? 1 : 0) - (facing === 0 ? 1 : 0);

    tilefacingx = clamp(x + tilefacingx, 0, COLS - 1);// compute target tile coords and clamp to grid bounds (make globals so handleInteract can read them)
    tilefacingy = clamp(y + tilefacingy, 0, ROWS - 1);

  //background scrolling
    const bgPosX = parseFloat(getComputedStyle(grid).backgroundPositionX) || 0;
    const bgPosY = parseFloat(getComputedStyle(grid).backgroundPositionY) || 0;
    const newBgPosX = bgPosX + backgroundScrollSpeedX;
    const newBgPosY = bgPosY + backgroundScrollSpeedY;
    grid.style.backgroundPosition = `${newBgPosX}px ${newBgPosY}px`;

  // CAMERA / GRID PANNING + PLAYER OFFSET
    (function panCamera() {
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const rect = grid.getBoundingClientRect();
      const gridW = rect.width || grid.offsetWidth || 0;
      const gridH = rect.height || grid.offsetHeight || 0;
      const cellSize = (COLS > 0) ? (gridW / COLS) : 0;

      // pixel position of player within the grid (relative to grid origin)
      const playerPx = (visx - 0.5) * cellSize;
      const playerPy = (visy - 1)   * cellSize;

      const centerX = Math.round(vw / 2);
      const centerY = Math.round(vh / 2);

      let desiredGridLeft;
      if (gridW <= vw) {
        // center grid horizontally if smaller than viewport
        desiredGridLeft = Math.round((vw - gridW) / 2);
      } else {
        // want player's in-grid pixel to be at viewport center -> grid left = center - playerPx
        desiredGridLeft = Math.round(centerX - playerPx);
        // clamp so grid never moves off-screen
        desiredGridLeft = clamp(desiredGridLeft, vw - gridW, 0);
      }

      let desiredGridTop;
      if (gridH <= vh) {
        desiredGridTop = Math.round((vh - gridH) / 2);
      } else {
        desiredGridTop = Math.round(centerY - playerPy);
        desiredGridTop = clamp(desiredGridTop, vh - gridH, 0);
      }

      // publish grid offsets and player offsets (player offset = same offset so player lines up with cells)
      document.body.style.setProperty('--gridoffsetx', `${desiredGridLeft}px`);
      document.body.style.setProperty('--gridoffsety', `${desiredGridTop}px`);
      document.body.style.setProperty('--playeroffsetx', `${desiredGridLeft}px`);
      document.body.style.setProperty('--playeroffsety', `${desiredGridTop}px`);
    })();

    // DEBUG OUTPUT
    debugBox.value =
      `Position: x=${x}, y=${y}\n` +
      `Tile Facing: ${tilefacingx},${tilefacingy}\n` +
      `Tileset Selected: ${selected ? `${selected.c},${selected.r}` : 'none'}`;
      //`Visual Position:   visx=${visx.toFixed(2)}, visy=${visy.toFixed(2)}\n` +
      //`Keys:     [${Array.from(keysHeld).join(', ')}]\n` +
      //`Moving:   ${moving}\n` +
      //`Facing:   ${facing}\n` +
      //`Animframe: ${animframe.toFixed(2)}\n` +
  }, 32); // 30 FPS game loop END

//INTERACTION HANDLER

  window.addEventListener('keydown', (e) => { // single-press listener (ignore repeats and when an input has focus)
    if (inputHasFocus()) return;
    if (e.repeat) return;
    const key = String(e.key || '');
    if (e.code === 'Space' || key.toLowerCase() === 'z' || key === 'Enter') {// interact keypress handling (single-press: Space, Z, Enter)
      e.preventDefault();
      handleInteract();
    }
  });

  function handleInteract() {  

    const raw = getComputedStyle(document.documentElement).getPropertyValue('--customhtml') || '';
    const clean = String(raw).trim().replace(/^['"]|['"]$/g, '');
    const lines = clean.split(/\r?\n/);

    const coordToken = `${tilefacingx},${tilefacingy}`;
    const urlRegex = /\bhttps?:\/\/[^\s]+/i;

    for (let raw of lines) {
      const line = raw.trim();
      if (!line) continue;

      const tokens = line.split(/\s+/); // quick presence check: exact token or substring like "2,4" present
      const matchIndex = tokens.findIndex(t => t === coordToken || t.replace(/[,]/g,'') === coordToken.replace(',',''));
      if (matchIndex === -1 && line.indexOf(coordToken) === -1) continue;

      // try to find a URL on the same line
      const u = line.match(urlRegex);
      if (u && u[0]) {
        // user-initiated keypress -> safe to open
        window.open(u[0], '_blank');
        return;
      }

      // if URL not found but the token is present, also check token+1 as probable link
      if (matchIndex >= 0 && tokens.length > matchIndex + 1) {
        const candidate = tokens[matchIndex + 1];
        if (candidate && urlRegex.test(candidate)) {
          window.open(candidate.match(urlRegex)[0], '_blank');
          return;
        }
      }

      // no URL: you could add handling for inline HTML or other actions here
    }
  }




// MENU TOGGLE
  const menu = document.getElementById('menu');
  const toggleMenuBtn = document.getElementById('toggleMenu');
  toggleMenuBtn.addEventListener('click', () => {
    if (menu.style.display === 'none' || getComputedStyle(menu).display === 'none') {
      menu.style.display = 'block';
    } else {
      menu.style.display = 'none';
      clearSelection(); // clear selection when menu is closed
    }
  });

  // ASSET UPLOADS (replace existing handlers with these minimal DataURL handlers)
  const tilesetInput = document.getElementById('tilesetInput');
  const backgroundInput = document.getElementById('backgroundInput');
  const playerInput = document.getElementById('playerInput');
  const debugBox = document.getElementById('debugBox');

  function fileToDataURL(file, cb) {
    const fr = new FileReader();
    fr.onload = () => cb(fr.result);
    fr.onerror = () => cb(null);
    fr.readAsDataURL(file);
  }

  tilesetInput.addEventListener('change', (ev) => {
    const f = ev.target.files && ev.target.files[0];
    if (!f) return;
    fileToDataURL(f, (dataUrl) => {
      if (!dataUrl) return;
      document.documentElement.style.setProperty('--tilesetsprite', `url("${dataUrl}")`);
      // convert CSS data: URL into a blob: URL for runtime use and revocation
      convertCssDataUrlVarToBlob('--tilesetsprite');
      if (debugBox) debugBox.value = dataUrl;
    });
  });

  backgroundInput.addEventListener('change', (ev) => {
    const f = ev.target.files && ev.target.files[0];
    if (!f) return;
    fileToDataURL(f, (dataUrl) => {
      if (!dataUrl) return;
      document.documentElement.style.setProperty('--worldbackgroundsprite', `url("${dataUrl}")`);
      // convert CSS data: URL into a blob: URL for runtime use and revocation
      convertCssDataUrlVarToBlob('--worldbackgroundsprite');
      if (debugBox) debugBox.value = dataUrl;
    });
  });

  playerInput.addEventListener('change', (ev) => {
    const f = ev.target.files && ev.target.files[0];
    if (!f) return;
    fileToDataURL(f, (dataUrl) => {
      if (!dataUrl) return;
      document.documentElement.style.setProperty('--playersprite', `url("${dataUrl}")`);
      // convert CSS data: URL into a blob: URL for runtime use and revocation
      convertCssDataUrlVarToBlob('--playersprite');
      if (debugBox) debugBox.value = dataUrl;
    });
  });

  // walk sound upload: set --walksound to data URL and update walkAudio
  const walksoundInput = document.getElementById('walksoundInput');
  if (walksoundInput) {
    walksoundInput.addEventListener('change', (ev) => {
      const f = ev.target.files && ev.target.files[0];
      if (!f) return;
      fileToDataURL(f, (dataUrl) => {
        if (!dataUrl) return;
        // set CSS var so saved HTML picks it up
        document.documentElement.style.setProperty('--walksound', `url("${dataUrl}")`);
        // update runtime Audio object
        try {
          if (walkAudio) {
            walkAudio.pause();
            walkAudio.src = dataUrl;
            walkAudio.load();
          } else {
            walkAudio = new Audio(dataUrl);
            walkAudio.preload = 'auto';
          }
        } catch (e) { /* ignore */ }
        if (debugBox) debugBox.value = 'Walk sound loaded';
      });
    });
  }

  let backgroundSpeedXInput = document.getElementById('backgroundSpeedX');
  let backgroundSpeedYInput = document.getElementById('backgroundSpeedY');
  backgroundSpeedXInput.value = String(backgroundScrollSpeedX || 0);
  backgroundSpeedYInput.value = String(backgroundScrollSpeedY || 0);
  backgroundSpeedXInput.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value) || 0;
    backgroundScrollSpeedX = v;
    document.documentElement.style.setProperty('--backgroundscrollspeedx', v);
  });
  backgroundSpeedYInput.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value) || 0;
    backgroundScrollSpeedY = v;
    document.documentElement.style.setProperty('--backgroundscrollspeedy', v);
  });

  let backgroundSizeInput = document.getElementById('backgroundSize');
  let bgSize = parseFloat(rootStyle.getPropertyValue('--backgroundsize')) || 100;
  backgroundSizeInput.value = String(bgSize);
  backgroundSizeInput.addEventListener('input', (e) => {
    const v = parseFloat(e.target.value) || 100;
    bgSize = v;
    document.documentElement.style.setProperty('--backgroundsize', `${v}%`);
  });

  // GRID SIZE CONTROLS: allow user to change --cols / --rows and rebuild grid
  const colsInput = document.getElementById('colsInput');
  const rowsInput = document.getElementById('rowsInput');
  if (colsInput) {
    colsInput.value = String(COLS || 16);
    colsInput.addEventListener('input', (e) => {
      let v = parseInt(e.target.value, 10) || 1;
      v = Math.max(1, Math.min(64, v));
      COLS = v;
      document.documentElement.style.setProperty('--cols', v);
      buildGrid();
    });
  }
  if (rowsInput) {
    rowsInput.value = String(ROWS || 16);
    rowsInput.addEventListener('input', (e) => {
      let v = parseInt(e.target.value, 10) || 1;
      v = Math.max(1, Math.min(64, v));
      ROWS = v;
      document.documentElement.style.setProperty('--rows', v);
      buildGrid();
    });
  }

  // CUSTOM HTML EDITOR
  const customHTML = document.getElementById('customHTML');
  const rawCustomhtml = rootStyle.getPropertyValue('--customhtml') || '';
  customHTML.value = String(rawCustomhtml).trim().replace(/^['"]|['"]$/g, '');
  customHTML.addEventListener('input', (e) => {
    let v = e.target.value.trim().replace(/^['"]|['"]$/g, '');
    customhtml = `"${v}"`;
    document.documentElement.style.setProperty('--customhtml', customhtml);
  });


// EDITOR
  for (let r = 0; r < PALETTE_ROWS; r++) { // build palette tiles
    for (let c = 0; c < PALETTE_COLS; c++) {
      const t = document.createElement('div');
      t.className = 'tile';
      // match the background-position formula in the page
      t.style.backgroundPosition = `${(100/15*c)}% ${(100/15*r)}%`;
      t.title = `tile ${c},${r}`;
      t.addEventListener('click', () => {
        // toggle selection
        const prev = palette.querySelector('.tile.selected');
        if (prev) prev.classList.remove('selected');
        t.classList.add('selected');
        selected = { c, r };
        selectedCoords.textContent = `${c},${r}`;
        preview.style.backgroundPosition = t.style.backgroundPosition;
      });
      palette.appendChild(t);
    }
  }

  function clearSelection() { // centralized clear function (used when menu closes)
    const prev = palette.querySelector('.tile.selected');
    if (prev) prev.classList.remove('selected');
    selected = null;
    selectedCoords.textContent = 'none';
    preview.style.backgroundPosition = '';
  }

  // Simplified grid paint handler: paint on pointerdown + pointermove while button held.
  window.addEventListener('DOMContentLoaded', attachGridHandler);
  if (document.readyState === 'complete') attachGridHandler();

  function attachGridHandler() {
    const gridEl = document.getElementById('grid');
    if (!gridEl) return;
    let drawing = false;

    const paintFromEvent = (ev) => {
      // use elementFromPoint so we still find the cell when moving fast
      const el = document.elementFromPoint(ev.clientX, ev.clientY) || ev.target;
      const cell = el && el.closest('.cell');
      if (!cell || !selected) return;
      cell.style.backgroundPosition = `${(100/15*selected.c)}% ${(100/15*selected.r)}%`;
      updateGridState();
    };

    gridEl.addEventListener('pointerdown', (ev) => {
      if (ev.button && ev.button !== 0) return;
      drawing = true;
      paintFromEvent(ev);
      ev.preventDefault();
    });

    gridEl.addEventListener('pointermove', (ev) => {
      if (!drawing) return;
      paintFromEvent(ev);
    });

    // stop drawing when button released anywhere
    window.addEventListener('pointerup', () => drawing = false);
  }

  function updateGridState() {
    const parts = [];
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const cell = grid.querySelector(`.cell[data-col="${c}"][data-row="${r}"]`);
        let tc = c, tr = r;
        if (cell) {
          const bp = (cell.style && cell.style.backgroundPosition) ? cell.style.backgroundPosition.trim() : '';
          const m = bp.match(/(-?\d+\.?\d*)%/g);
          if (m && m.length >= 2) {
            tc = Math.round(parseFloat(m[0]) * 15 / 100);
            tr = Math.round(parseFloat(m[1]) * 15 / 100);
            tc = clamp(tc, 0, 15);
            tr = clamp(tr, 0, 15);
          }
        }
        parts.push(`${tc},${tr}`);
      }
    }

    const state = parts.join(' ');
    document.documentElement.style.setProperty('--gridstate', `"${state}"`);
    if (typeof debugBox !== 'undefined' && debugBox) debugBox.value = `--gridstate updated: ${state}`;
    return state;
  }

  // SAVE PAGE: update only opening <html ...> style (require original HTML before allowing Save)
const sourceHtmlInputEl = document.getElementById('sourceHtmlInput');
const saveButtonEl = document.getElementById('saveButton');
let ORIGINAL_SOURCE = null;
if (saveButtonEl) saveButtonEl.disabled = true;

if (sourceHtmlInputEl) {
  sourceHtmlInputEl.addEventListener('change', (ev) => {
    const f = ev.target.files && ev.target.files[0];
    if (!f) {
      ORIGINAL_SOURCE = null;
      if (saveButtonEl) saveButtonEl.disabled = true;
      alert('Original HTML cleared.');
      return;
    }
    const r = new FileReader();
    r.onload = () => {
      const txt = String(r.result || '');

      // validate start: must contain doctype and an <html ... lang="ANY" ... style='...'> on top,
      // ignoring linebreaks/extra whitespace and allowing single or double quotes for attributes.
      const startsWithDoctype = /^\s*<!doctype\s+html>/i.test(txt);
      const htmlWithLangAndStyle = /<html[^>]*\blang\s*=\s*['"][^'"]+['"][^>]*\bstyle\s*=\s*['"]/i.test(txt.slice(0, 2000)); // allow any lang value (not forcing "en")

      if (!startsWithDoctype || !htmlWithLangAndStyle) {
        ORIGINAL_SOURCE = null;
        if (saveButtonEl) saveButtonEl.disabled = true;
        alert('Uploaded file does not look like the original HTML. It must start with <!doctype html> and include <html lang=\"...\" style=...> at the top.');
        return;
      }

      ORIGINAL_SOURCE = txt;
      if (saveButtonEl) saveButtonEl.disabled = false;
      alert('Original HTML file loaded successfully. You can now save your changes.');
    };
    r.onerror = () => {
      ORIGINAL_SOURCE = null;
      if (saveButtonEl) saveButtonEl.disabled = true;
      alert('Failed to read uploaded HTML file.');
    };
    r.readAsText(f);
  });
}

if (saveButtonEl) {
  saveButtonEl.addEventListener('click', () => {
    if (!ORIGINAL_SOURCE) {
      alert('Please upload the original HTML file before saving.');
      return;
    }

    // build list of CSS custom properties currently set on the <html> element's inline style
    const htmlInlineStyle = document.documentElement.getAttribute('style') || '';
    const varRegex = /(--[a-zA-Z0-9\-_]+)\s*:/g;
    const varsToCapture = [];
    let m;
    while ((m = varRegex.exec(htmlInlineStyle))) {
      if (!varsToCapture.includes(m[1])) varsToCapture.push(m[1]);
    }
    if (varsToCapture.length === 0) {  // if no vars found in inline html style, try to pull defaults from the uploaded original HTML
      const htmlStyleMatch = ORIGINAL_SOURCE.match(/<html[^>]*\bstyle\s*=\s*(['"])([\s\S]*?)\1/i);
      if (htmlStyleMatch && htmlStyleMatch[2]) {
      const htmlStyleText = htmlStyleMatch[2];
      const inlineVarRegex = /(--[a-zA-Z0-9\-_]+)\s*:\s*([^;]+);?/g;
      let mm;
      while ((mm = inlineVarRegex.exec(htmlStyleText))) {
        if (!varsToCapture.includes(mm[1])) varsToCapture.push(mm[1]);
      }
      }
      alert('Unable to determine CSS custom properties to save. Ensure the original HTML contains an inline style on the <html> tag with the variables.'); // if still nothing found, abort save and inform the user
      return;
    }
    const cs = getComputedStyle(document.documentElement);
    const lines = varsToCapture.map(v => `${v}: ${cs.getPropertyValue(v).trim()};`);

    // preserve whatever lang the uploaded file used (fall back to 'en' if not present)
    const langMatch = ORIGINAL_SOURCE.match(/^<html[^>]*\blang\s*=\s*(['"])(.*?)\1/i);
    const langVal = (langMatch && langMatch[2]) ? langMatch[2] : 'en';
    const newHtmlOpen = `<html lang="${langVal}" style='\n${lines.join('\n')}\n'>`;

    // replace the first <html ...> tag wherever it appears (after <!doctype> usually)
    let replaced = ORIGINAL_SOURCE.replace(/<html[^>]*>/i, newHtmlOpen);
    // if no <html> tag was found at all, prepend the new opening tag
    if (replaced === ORIGINAL_SOURCE) replaced = newHtmlOpen + '\n' + ORIGINAL_SOURCE;
    
    const blob = new Blob([replaced], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'yumelinks_saved.html';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });
}
</script>

<style>

body {
  --visx: 2;
  --visy: 2;
  --playerspriteframex: 0%;
  --playerspriteframey: 0%;
  --gridoffsetx: 0px;
  --gridoffsety: 0px;
  --playeroffsetx: 0px;
  --playeroffsety: 0px;

  --blob_tilesetsprite: null;
  --blob_worldbackgroundsprite: null;
  --blob_playersprite: null;

  overflow: hidden; height: 100vh; width: 100vw; overscroll-behavior: none;
}

  *,*::before,*::after { top: 0; left: 0; margin: 0; padding: 0; border: 0; outline: 0; box-shadow: none; text-decoration: none; -webkit-appearance: none; appearance: none; box-sizing: border-box; image-rendering: crisp-edges; image-rendering: pixelated;}
  body { height:100%; margin:0; display:flex; align-items:center; justify-content:center; background:#000000; }

.grid {
  position: absolute;
  top: var(--gridoffsety);  left: var(--gridoffsetx);
  display: grid;
  gap: 0;
  grid-template-columns: repeat(var(--cols), var(--cell-size));  grid-template-rows: repeat(var(--rows), var(--cell-size));
  --cell-size: calc(100vmin / 16);
  width: calc(var(--cols) * var(--cell-size));  height: calc(var(--rows) * var(--cell-size));
  background-image: var(--blob_worldbackgroundsprite);
  background-size: var(--backgroundsize), auto;
}
.cell {
  background-image: var(--blob_tilesetsprite);
  background-repeat: no-repeat;
  background-size: calc(100% * 16) calc(100% * 16);
  background-position: calc(100%/15 * var(--col)) calc(100%/15 * var(--row));
  width: 101%;  height: 101%;
  /* performance hints */
  contain: paint;                       /* limit layout/paint scope to each cell */
  will-change: transform, background-position; /* hint likely changing properties */
  transform: translateZ(0);             /* promote to compositor layer */
  backface-visibility: hidden;          /* small GPU/paint perf help */
  /* keep pointer-events if you need painting via pointer events */
  pointer-events: auto;
}
.player {
  position: absolute;
  top: calc(((var(--visy) - 1) * var(--cell-size)) + var(--playeroffsety));
  left: calc(((var(--visx) - 0.5) * var(--cell-size)) + var(--playeroffsetx));
  background-image: var(--blob_playersprite);
  background-size: calc(100% * 4) calc(100% * 4);
  background-position: var(--playerspriteframex) var(--playerspriteframey);
  --cell-size: calc(100vmin / 16);
  width: calc(var(--cell-size)*2);  height: calc(var(--cell-size)*2);
}
.menu {
  display:none;
  position: absolute;
  right: 0px;
  left: auto;
  max-width: 512px;
  background: rgba(255, 255, 255, 0.8);
  max-height: 100vh;
  overflow-y: scroll;
}
.palette {
  display: grid;
  grid-template-columns: repeat(16, 20px);
  grid-auto-rows: 20px;
  gap: 2px;
  padding: 6px;
  background: rgba(0,0,0,0.05);
  border-radius: 4px;
  margin-top: 8px;
  width: max-content;
}
.palette .tile {
  width: 20px;
  height: 20px;
  background-image: var(--tilesetsprite);
  background-size: calc(100% * 16) calc(100% * 16);
  cursor: pointer;
  box-sizing: border-box;
  border: 1px solid transparent;
}
.palette .tile.selected {
  border-color: #f00;
  outline: 2px solid rgba(255,0,0,0.25);
}
.tile-preview {
  display:inline-block;
  vertical-align: middle;
  width: 28px;
  height: 28px;
  margin-left: 8px;
  background-image: var(--tilesetsprite);
  background-size: calc(100% * 16) calc(100% * 16);
  border: 1px solid #999;
}
.palette-row {
  display:flex;
  align-items:center;
  gap:8px;
  margin-top:6px;
}
#toggleMenu {
  position: fixed;
  top: 5px;
  right: 5px;
  left: auto;
}
#customHTML,
#debugBox {
  width: calc(100% - 12px);
  font-family: monospace;
  font-size: 12px;
  margin-top: 6px;
}
</style>
</body>
</html>




